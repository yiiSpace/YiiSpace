The Environment
=======

在shell 会话期间 shell维护了一个信息体称为 `environment` 程序使用存储在
环境中的数据来决策关于系统配置的相关方面  而很多程序使用配置文件来存储程序设定（program settings）
另一些程序也在环境变量中寻找一些值来调整其行为 知道这个后 我们可以使用环境变量来定制我们的shell体验

本章 我们会使用以下的命令

- printenv 打印部分或者全部的环境
- set 设置shell 选项
- export 导出环境给后续执行的程序。
- alias 创建 命令的别名

### 环境中存了什么
shell 在环境中存储了两种基本类型的数据

他们是 environment variables 和 shell variables 

shell 变量就是由shell存放的一点数据 

除了变量 shell也存储一些程序性数据 命名的 别名或者是shell函数

### 查看环境

使用 set 内建bash 或者printenv 程序
> printenv | less


我们会看到环境变量和其值的列表 

也可以打印单个环境变量的值：
> yiqing@yiqing-VirtualBox:~$ printenv  USER
  yiqing


使用set 
> set | less

也可以使用echo命令来查看一个变量
> yiqing@yiqing-VirtualBox:~$ echo $HOME
  /home/yiqing
  
环境变量使用printenv 和 set 都不会显示的就是别名了
使用不带参数的alias命令来查看他们
> yiqing@yiqing-VirtualBox:~$ alias
  alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
  alias egrep='egrep --color=auto'
  alias fgrep='fgrep --color=auto'
  alias grep='grep --color=auto'
  alias l='ls -CF'
  alias la='ls -A'
  alias ll='ls -alF'
  alias ls='ls --color=auto'


一些有趣的变量

Environment Variables

Variable                        Contents
DISPLAY                         The name of your display if you are running a graphical environment.
                                Usually this is :0, meaning the first display generated by the X server.
EDITOR                          The name of the program to be used for text editing.
SHELL                           The name of your shell program.
HOME                            The pathname of your home directory.
LANG                            Defines the character set and collation order of your language.
OLDPWD                          The previous working directory.
PAGER                           The name of the program to be used for paging output. This is often set to
                                /usr/bin/less.
PATH                            A colon-separated list of directories that are searched when you enter the
                                name of a executable program.
PS1                             Stands for “prompt string 1.“ This defines the contents of the shell prompt.
                                As we will later see, this can be extensively customized.
PWD                             The current working directory.
TERM                            The name of your terminal type. Unix-like systems support many terminal
                                protocols; this variable sets the protocol to be used with your terminal
                                emulator.
TZ                              Specifies your time zone. Most Unix-like systems maintain the computer’s
                                internal clock in Coordinated Universal Time (UTC) and then display the
                                local time by applying an offset specified by this variable.
USER                            Your username.  

根据发行版的不同 这些变量可能不一样！

### 环境变量如何被建立

当我们登入系统时 ，bash程序启动 并读取一系列配置脚本称之为 startup files 启动文件 这定义了被所有用户共享的默认环境
此后在我们home文件夹下的启动文件也被读入 这些定义了我们个人的环境。确切的执行顺序根据shell类型决定 有两类：

- A login shell session 这个就是哪个提示我们输入自己的用户名和密码 比如这个发生在我们启动一个虚拟控制会话时

- A non-login shell session 这典型的发生在GUI中我们加载一个终端会话的时候

登录shell 读取一个或者多个启动文件 

Startup Files for Login Shell Sessions

File                    Contents
/etc/profile            A global configuration script that applies to all users.
~/.bash_profile         A user’s personal startup file. It can be used to extend or override
                        settings in the global configuration script.
~/.bash_login           If ~/.bash_profile is not found, bash attempts to read this script.
~/.profile              If neither ~/.bash_profile nor ~/.bash_login is found, bash attempts
                        to read this file. This is the default in Debian-based distributions,
                        such as Ubuntu.
                        
非login shell 读取这些启动文件：
Startup Files for Non-Login Shell Sessions

File                        Contents
/etc/bash.bashrc            A global configuration script that applies to all users.
~/.bashrc                   A user’s personal startup file. It can be used to extend or override
                            settings in the global configuration script.    
                            
除了读取这些文件 非登录shell也从其父进程继承环境 经常是一个登录shell 。

这些文件基本都是隐藏文件  使用ls -a 来查看他们

~/.bashrc文件 对常规用户而言 可能是最重要的启动文件  因为它几乎总是被读到。非登录shell默认会读它，并且
用于登录shell的大部分启动文件以此种方式写成 通读取~/.bashrc文件一样。

### 什么是启动文件？
看个典型的.bash_profile( centos 6 )：

~~~shell

# .bash_profile
# Get the aliases and functions
if [ -f ~/.bashrc ]; then
. ~/.bashrc
fi
# User specific environment and startup programs
PATH=$PATH:$HOME/bin
export PATH

~~~      

以#开始的事注释 shell不会读取 这些是为了人类的可读性 第一个有趣的事情出现在第四行 有一下的代码：
> if [-f ~/.bashrc ]; then
        . ~/.bashrc
  fi
  
这本称为一个 if组合命令  在第五部分shell编程时会全面介绍目前只需要知道它翻译如下：
> If the file "~/.bashrc" exists, then
         read the "~/.bashrc" file.            
         
如果文件存在 就读取

这点代码就是login shell 如何获取.bashrc的内容        在启动文件中下面的事情跟PATH变量有关
都想知道当我们进入shell时在命令行中shell如何懂得在什么地方去寻找命令   比如当我们输入 ls shell不会在整个电脑寻找 /bin/ls
而是 它在一个目录列表中搜索 他们被包含在PATH变量中
PATH变量经常（但不总是 依赖于发行）被/etc/profile文件设置 用这些代码：
> PATH=$PATH:$HOME/bin
PATH 被修改为添加一个目录 $HOME/bin在列表末尾 这是一个参数展开的例子(parameter expansion)

为了演示这是怎么工作的 试下下面的代码：
~~~shell
yiqing@yiqing-VirtualBox:~$ foo="This is some"
yiqing@yiqing-VirtualBox:~$ echo $foo
This is some
yiqing@yiqing-VirtualBox:~$ foo=$foo" text."
yiqing@yiqing-VirtualBox:~$ echo $foo
This is some text.

~~~          

使用这种技术 我们可以添加文本在变量内容的尾部。

$HOME/bin被添加到了环境变量PATH的尾部 
存储自己私有的程序在这里

NOTE 注意很多发行版默认提供了此PATH设置    基于Debian的发行版 比如Ubuntu 在登录时检测~/bin的存在性并动态地添加其到PATH变量中
如果目录被找到的话

最后 我们有这个：
> export PATH

export 命令告诉shell让PATH的内容对此shell的子进程可用   

## 修改Environment
因为我们知道启动文件在哪里 以及它包含什么内容 我们可以修改他们来定制我们的环境

我们应该修改那些文件？
常规规则 添加目录到PATH或者定义额外环境变量 将变更放在 .bash_profile(或者等价文件 根据发行版而定  比如在Ubuntu中用 .profile)
对于其他情况 将变更放在.bashrc

NOTE 注意除非你是管理员并且需要修改对系统所有用户的默认设置 否则限制你的修改在你的home目录下的文件 当然可能修改/etc下的文件
比如profile 在大部分情况下这样搞是比较敏感的

Text Editors
为了编辑（修改）shell的启动文件 或者系统的其他配置文件 我们使用一个程序称之为 text editor 一个文本编辑器是一个程序

linux下有很多不同的文本编辑器 很多系统安装了好几个 为啥这么多不同的编辑器？ 因为程序员喜欢写他们（呃！吃饱了没事干）
他们写出编辑器来表达希望他们怎样工作的愿望     

编辑器 落入两类基本的分类: 基于图形的或者 文本的
图形的 
- GNOME    :   gedit
- KDE： kedit kwrite  kate

文本的
最流行的一些是
nano（简单易用 作为pico编辑器的替代品 pico编辑器用于PINE邮件套装） vi（很多linux系统都有 在unik-like系统上是传统编辑器  已经被vim取代 vim即--vi improved） emacs（Richard Stallman 写的
默认未被安装）

### 使用一个文本编辑器
文本编辑器可以从命令行调用 通过输入编辑器名称 跟一个想要编辑的文件名 如果文件名不存在 编辑器会假定我们想要创建这个新文件
> gedit some_file

这个命令会启动一个 gedit文本编辑器 并且如果文件some_file存在还会加载它 图形编辑器没啥说的 自解释的
我们会关注我们的第一个文本编辑器 nano   并编辑.bashrc文件 但在此之前 让我们做一些“安全计算”
不论何时在我们编辑一个重要的配置文件的时候 先创建一个备份副本总是一个好主意 
>cp .bashrc .bashrc.bak

不管备份叫啥 好理解的名字就行  扩展如：.bak .sav .old .orig 都是经常流行的方式用以标识备份文件 。哦 记得 cp 会默默地覆盖
已经存在的文件

现在有了备份文件 我们可以开始编辑器了
> nano .bashrc

在任何文本编辑器中 首先要学的第一个命令就是退出程序   nano中 CTRL X 
第二个命令 我们需要知道的就是 如何保存我们的工作 ctrl O
有这些知识后 我们可以做一些编辑工作了 使用 上下键或者 上页下页来移动鼠标到文件的尾部 之后添加以下的行给.bashrc文件
>  umask 0002
   export HISTCONTROL=ignoredups
   export HISTSIZE=1000
   alias l.='ls -d .* --color=auto'
   alias ll='ls -l --color=auto'
   
   NOTE 你发行版可能已经有这些内容了 但重复下无伤大雅
   意思如下：
   
   Additions to Our .bashrc
   
   Line                     Meaning
   umask 0002               Sets the umask to solve the problem with the shared
                            directories we discussed in Chapter 9.
   export HISTCONTROL=ignoredups    Causes the shell’s history recording feature to
                                        ignore a command if the same command was just
                                         recorded.
   export HISTSIZE=1000             Increases the size of the command history from the
                                     usual default of 500 lines to 1,000 lines.
   alias l.='ls -d .* --color=auto' Creates a new command called l., which displays
                                     all directory entries that begin with a dot.
   alias ll='ls -l --color=auto'        Creates a new command called ll, which displays
                                     a long-format directory listing.
                                     
添加注释是个好主意

> 无论何时修改了配置文件 为你的更改添加一些注释 当然你可能明天会记得你改了啥 但六个月以后呢？
   shell 脚本实用 # 开始一个注释 其他配置文件可能实用其他符号 很多配置文件都有注释 可以用其作为guide 
   有的配置文件里面的注释 经常列出可能的配置形式       
   
### 激活我们的改变

关掉并重启终端会话可看生效变更 .bashrc文件只有在会话开始时才读入     然而我们可以强制bash重新读取修改过的.bashrc文件
用下面的命令：
> source ~/.bashrc

此后 可以看到变更的效果 试试别名中的一个
> ll                            
   