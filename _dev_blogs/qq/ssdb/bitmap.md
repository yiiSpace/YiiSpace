
2015/11/16 19:55:40
天晴 2015/11/16 19:55:40
创建一个
找我私聊者踢 2015/11/16 19:56:06
不能了, 操作系统的文件删除, 几乎无法找回.
刘飞 2015/11/16 19:56:55
可以把备份文件导入吧
找我私聊者踢 2015/11/16 19:57:13
可以
2015/11/16 19:57:28
找我私聊者踢 2015/11/16 19:57:28
按文档的步骤操作吧.
找我私聊者踢 2015/11/16 19:57:35
有备份就好说
刘飞 2015/11/16 19:58:41
好的 谢谢
2015/11/16 20:20:06
找我私聊者踢 2015/11/16 20:20:06
@刘飞  恢复了吗? 
2015/11/16 20:33:19
刘飞 2015/11/16 20:33:19
备份文件 要考到 固定目录下吗
刘飞 2015/11/16 20:34:35

刘飞 2015/11/16 20:34:39
这样也不行
2015/11/16 20:36:11
找我私聊者踢 2015/11/16 20:36:11
你是怎么备份的?
找我私聊者踢 2015/11/16 20:36:21
.rdb 是 redis 的备份, 不是 ssdb 的备份.
刘飞 2015/11/16 20:36:48
哦 不要意思 弄错了。
2015/11/16 20:42:30
刘飞 2015/11/16 20:42:30
可以了。
刘飞 2015/11/16 20:43:46
领导不靠谱啊，居然把var删除了。哎。。。我以为他很懂。
2015/11/16 20:48:28
找我私聊者踢 2015/11/16 20:48:28

刘飞 2015/11/16 20:49:16

数据库文件 怎么没看到 
刘飞 2015/11/16 20:49:33
导入成功了。目录下应该是那个文件
2015/11/16 20:52:45
找我私聊者踢 2015/11/16 20:52:45
000005.log
刘飞 2015/11/16 20:54:38
好的 感谢！
2015/11/17 11:47:43
dodo 2015/11/17 11:47:43
https://github.com/IronsDu/DBProxy/blob/master/README.md
更新了一些介绍。
2015/11/17 12:00:36
刘飞 2015/11/17 12:00:36

2015/11/17 17:06:06
叶落无声 2015/11/17 17:06:06
setbit9位长度正常 11位正常 10位挂了，请问是啥原因啊
2015/11/17 17:14:52
找我私聊者踢 2015/11/17 17:14:52
setbit key offset val
找我私聊者踢 2015/11/17 17:15:03
offset 太长了, 可能服务端没判断好
叶落无声 2015/11/17 17:15:44
很奇怪的是 offset9位和11位的时候都正常工作
叶落无声 2015/11/17 17:15:52
10位的时候直接弄死了进程
找我私聊者踢 2015/11/17 17:16:24
你这不是10位

2015/11/17 17:16:54
找我私聊者踢 2015/11/17 17:16:54
是39亿位
2015/11/17 17:17:58
叶落无声 2015/11/17 17:17:58
好吧 那这么说 亿位和百亿位工作正常 十亿位出错
找我私聊者踢 2015/11/17 17:18:41
如果你想设置第11位, 应该这样: setbit key 11 1
叶落无声 2015/11/17 17:19:06
不不 我就是想这样用。虽然这个例子比较几段
叶落无声 2015/11/17 17:19:08
极端
2015/11/17 17:20:15
叶落无声 2015/11/17 17:20:15
在我的使用场景里面offset上限=系统最大用户ID
叶落无声 2015/11/17 17:21:00
所以39亿位极端了点，但是亿级别的位数是完全可能的
找我私聊者踢 2015/11/17 17:21:00
明白你的需求了. 解决方案就是不能这么用, 按别的方式.
找我私聊者踢 2015/11/17 17:21:13
新版本会加上限制 offset 的上限.
找我私聊者踢 2015/11/17 17:21:21
一般在几百成, 现在还没定.
找我私聊者踢 2015/11/17 17:21:26
几百万
叶落无声 2015/11/17 17:21:34
几百万少了一点把
找我私聊者踢 2015/11/17 17:21:42
设计如此.
2015/11/17 17:23:11
叶落无声 2015/11/17 17:23:11
那这个需求只能使用redis的bitmap来处理了
如果的如果 2015/11/17 17:23:24

叶落无声 2015/11/17 17:23:36
不过方便告知下为何限制到几百万吗？
如果的如果 2015/11/17 17:23:40
redis硬件成本好高
找我私聊者踢 2015/11/17 17:24:10
因为用一个长字符串来实现, 字符串的长度=max bit offset/8
找我私聊者踢 2015/11/17 17:24:27
因为内存占用等考虑, 限制在几MB长度
2015/11/17 17:24:40
叶落无声 2015/11/17 17:24:40
因为在redis中bitmap一个很重要的用途就是这样用，一个用户占据一个位，通过多条件键的交并集计算来实现很多的统计功能
远航の海贼 2015/11/17 17:24:57
offset是一个int类型，3892938420这个数越界了，转成int刚好是一个负数，分配内存失败了吧
2015/11/17 17:26:07
小陈 2015/11/17 17:26:07
redis的hyperlog精度差些，但是内存占用少
叶落无声 2015/11/17 17:26:11
所以百万级别确实太少了一点，
找我私聊者踢 2015/11/17 17:26:51
建议你换种思路.
远航の海贼 2015/11/17 17:27:06
offset可以支持到20多亿吧
远航の海贼 2015/11/17 17:27:29
int类型上限
2015/11/17 17:29:53
叶落无声 2015/11/17 17:29:53
redis可以支持到42亿多，单键值512MB
2015/11/17 17:49:16
找我私聊者踢 2015/11/17 17:49:16
新版本 offset 限制在 [0, 1073741824]
叶落无声 2015/11/17 17:50:03
这个好 够用了 
叶落无声 2015/11/17 17:50:57
下个版本中bitop会加入吗？
找我私聊者踢 2015/11/17 17:51:12
暂时不考虑
2015/11/17 17:54:08
找我私聊者踢 2015/11/17 17:54:08
bit 操作是非常底层的操作, 而 ssdb 离业务更近. 以前有些程序员在设计数据库字符时, 偶尔会使用位操作来表示状态(status), 自以为很聪明, 其实很愚蠢, 许多查询用不了索引.
吴承宪 2015/11/17 17:54:27

吴承宪 2015/11/17 17:54:46
bit， 人不可读
找我私聊者踢 2015/11/17 17:54:46
所以, 对于数据库层面, 首先要避免位操作.
牛牛 2015/11/17 17:55:00
擦，都来了啊
如果的如果 2015/11/17 17:55:12

吴承宪 2015/11/17 17:55:17
不写驱动，尽量别用bit
2015/11/17 17:58:14
叶落无声 2015/11/17 17:58:14
我是想这样用，这种思路问题出在何处呢？
叶落无声 2015/11/17 17:59:00

找我私聊者踢 2015/11/17 17:59:07
hset today_online uid ""
找我私聊者踢 2015/11/17 17:59:26
用一个 hash 或者 zset 保存登录用户的 uid 列表即可.
2015/11/17 18:00:29
找我私聊者踢 2015/11/17 18:00:29
简单, 直观好理解, 更种层次水平的程序员都能维护.
叶落无声 2015/11/17 18:02:04
OK，比如day1的登录情况一个hash,day2的登录情况一个hash,....一直到day30,那么我想知道day1到day30每天都登录的用户数有多少怎么操作？
2015/11/17 18:02:34
叶落无声 2015/11/17 18:02:34
hash中可没办法做并集啊
找我私聊者踢 2015/11/17 18:02:41
算法你肯定懂. 只是你纠结什么时候做计算.
2015/11/17 18:03:47
找我私聊者踢 2015/11/17 18:03:47
老纠结"性能", "空间"什么的, 其实你这个需求, 直接了当地解决问题就好了. 
叶落无声 2015/11/17 18:03:58
求解惑
找我私聊者踢 2015/11/17 18:05:07
tmp = new set();
foreach(day1 as uid){
	tmp.add(uid);
}
foreach(day2 as uid){
	tmp.add(uid);
}
...
echo tmp.count();
找我私聊者踢 2015/11/17 18:05:13
这个算法我不认为你不懂.
2015/11/17 18:05:41
叶落无声 2015/11/17 18:05:41
。好吧 
找我私聊者踢 2015/11/17 18:05:42
这是总的登录用户数, 去重.
找我私聊者踢 2015/11/17 18:05:50
如果是求每天的, echo day1.count();
叶落无声 2015/11/17 18:06:10
但是我想知道每天都登录的用户
找我私聊者踢 2015/11/17 18:06:11
因为  hash/zset 是可以求出元素数量的.
叶落无声 2015/11/17 18:06:22
也就是所谓的活跃度计算
叶落无声 2015/11/17 18:06:56
再扩展一点，我需要加入用户属性的过滤
叶落无声 2015/11/17 18:07:14
比如我要提取某个地区某种设备的用户登录情况
找我私聊者踢 2015/11/17 18:07:38
离线计算.
2015/11/17 18:10:52
叶落无声 2015/11/17 18:10:52
。
tmp = new set();
foreach(day1 as uid){
	tmp.add(uid);
}
foreach(day2 as uid){
	tmp.add(uid);
}
...
echo tmp.count();
再回到这段代码，假设我每个set中都有1KW成员，30天，也就是说我做这个统计 我要做30x1KW = 3亿次函数调用，就算是离线计算，这代价也是比较昂贵的吧？
找我私聊者踢 2015/11/17 18:11:23
 so what?
2015/11/17 18:19:05
吴承宪 2015/11/17 18:19:05
要求有多实时？ 
吴承宪 2015/11/17 18:19:25
1分钟出统计数据？
吴承宪 2015/11/17 18:19:33
1天出统计数据
吴承宪 2015/11/17 18:20:11
后续什么层次的人来维护 ？
吴承宪 2015/11/17 18:20:15
新的统计需求？
2015/11/17 18:24:04
dodo 2015/11/17 18:24:04
每天都登录的？先把ssdb数据搞到内存了，然后写算法计算。
2015/11/17 18:31:33
Kael 2015/11/17 18:31:33
为什么要把所有的计算任务都交给数据库呢
2015/11/17 18:39:46
dodo 2015/11/17 18:39:46
nosql本来就不能做计算，估计他不习惯，不敢认为群主给的方式是对的。
9:33:46
        亦清 2015/11/18 9:33:46
@叶落无声 你这些资料出自何处 看起来很不错 有链接分享不？
