正则式
=====

参考： [正则表达式 问号 冒号 ?:使用](http://blog.sina.com.cn/s/blog_6acdaf6d01016a67.html)

~~~

(?:  pattern)是非捕获型括号  匹配pattern，但不捕获匹配结果。
(pattern )是捕获型括号。  匹配pattern，匹配pattern并捕获结果,自动获取组号
(?<name> pattern )  匹配pattern，  匹配pattern并捕获结果，设置name为组名 
    使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个捕获组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 
    如果正则表达式中同时存在普通捕获组和命名捕获组，那么捕获组的编号就要特别注意，编号的规则是先对普通捕获组进行编号，再对命名捕获组进行编号。 
     为了避免括号太多使编号混乱，也为了避免无用的捕获提高效率，在不需要捕获只需要指定分组的地方就可以使用非捕获型括号。问题里的非捕获型括号就是为此使用的。
~~~


## 反向引用

捕获后 就可以使用 反向引用了
-  内部反向引用 (\d)\1              匹配连续两个(数字)            \1 即表示捕获的分组匹配序号 依次类推 \2  \3 ...
-  外部反向引用 使用 $1 $2 $n ...来引用   参考[php中正则表达式详解](https://www.cnblogs.com/pengyunjing/p/6579461.html)

 将字符串中”age13gegep3iorji65k65k”;中出现的连续两个数字改为第二个数字，如字符串中13被改为3

~~~php

$str = 'age13gegep3iorji65k65k';
$pattern = '/(\d)(\d)/';
$str = preg_replace($pattern,'$2', $str);
~~~   
 解析：$n在正则表达式外使用反向引用。n代表第几次匹配到的结果。
 
 
 ## 固态分组
 
 形式：  (?>...)    
 
 这个话题跟 **回溯** 有关
 
 ### 回溯
 
 首先我们需要清楚什么是回溯，回溯就像是在走岔路口，当遇到岔路的时候就先在每个路口做一个标记。
 如果走了死路，就可以照原路返回，直到遇见之前所做过的标记，标记着还未尝试过的道路。
 如果那条路也走不能，可以继续返回，找到下一个标记，如此重复，直到找到出路，或者直到完成所有没有尝试过的路
 
 ~~~php
 
 $str='aageacwgewcaw';
 $pattern='/a\w*c/i';
 $str=preg_match($pattern, $str);
 
 ~~~
 
 固态分组，目的就是减少回溯次数，
 使用(?>…)括号中的匹配时如果产生了备选状态，那么一旦离开括号便会被立即 引擎抛弃掉。
 举个典型的例子如： ‘\w+:’这个表达式在进行匹配时的流程是这样的，会优先去匹配所有的符合\w的字符，
 假如字符串的末尾没有’:’，即匹配没有找到冒号，此时触发回溯机制，他会迫使前面的\w+释放字符，并且在交还的字符中重新尝试与’:’作比对。
 但是问题出现在这里: \w是不包含冒号的，显然无论如何都不会匹配成功，可是依照回溯机制，引擎还是得硬着头皮往前找，这就是对资源的浪费。
 所以我们就需要避免这种回溯，对此的方法就是将前面匹配到的内容固化，不令其存储备用状态！，那么引擎就会因为没有备用状态可用而只得结束匹配过程。
 大大减少回溯的次数。 
 如下代码，就不会进行回溯：
 
 ~~~php
 
 $str='nihaoaheloo';
 $pattern='/(?>\w+):/';
 $rs=preg_match($pattern, $str);
 ~~~
 
 当然有的时候，又需慎用固态分组，
 如下,我要检查$str中是否包含以a结尾的字符串，
 很明显是包含的，但是因为使用了固态分组，反而达不到我们想要的效果
 
 ~~~php
 
 $str='nihaoahelaa';
 $pattern1='/(?>\w+)a/';
 $pattern2='/\w+a/';
 $rs=preg_match($pattern1, $str);//0
 $rs=preg_match($pattern2, $str);//1
 ~~~